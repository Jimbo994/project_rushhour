def BreadthFirst(vehicles):
    old_boards = {}
    # queue begint met de startconfiguratie, dan moeten hier alle kinderen van gemaakt worden (met get_board) en dan gepopt worden
    Q = Queue()
    # startconfiguratie board toevoegen aan de Queue
    Q.enqueue(vehicles)
    # zolang queue niet leeg is:
    while Q.size != 0:
        # dan halen we het board uit de Queue 
        # maar ik weet dus niet zeker of het slim is om te zeggen dequeue(board) Misschien slimmer om gewoon het item dat het eerste erin is gestopt te poppen.
        # want later in de code enqueun we de moves uit vehicle.get_moves en dan heten ze dus ook move... toch?
            
        new_vehicle = Q.dequeue()
            
            # als het bord al in de old_boards staat dan doen we er niks mee en gaan we door
            if str(new_vehicle) in old_boards:
                continue
            # als we hem nog niet in de old_boards hadden dan moet ie er bij.
            else:
                old_boards[str(new_vehicle)] =  new_vehicle
                
            # Nu checken of het bord al een oplossing is
            # we moeten dus gaan kijken of auto met ID X dan op de juiste positie staat. 
            # alleen die array vehicles[] kunnen we dan niet gebruiken als geldige code.
            # ik zat te denken aan zoiets, maar weet dus niet of als we dat board noemen of dat werkt.
            # even uitzoeken wat de winnend coordinaten ook alweer precies zijn (ik ben lui, het is laat)
            #new_vehicleboard = Board.get_board(new_vehicle)
            #if new_vehicleboard[2][4] == 'X' and new_vehicleboard[2][5] == 'X':
                #print "we won"
                #print new_vehicleboard.__str__            
            # wat misschien ook kan is
            
            if Vehicle('x', 4, 2, 'H') in new_vehicle:
                print "We won! :)"
                break
            
            # zo nee, volgende move halen en daarmee weer dit proces doorlopen.
            else:
                for new_vehicles in vehicles.get_moves(vehicles):
                    Q.enqueue(new_vehicles)
            # en dan hier alles            
            #queue.extendleft((move, new_path) for move in board.moves())
        
        # get_moves callen per auto
        # check for board state
        # alle mogelijke moves van een auto
        # moves hier maken 
        # opslaan welke moves er zijn gemaakt met welke auto
            # tuple aanmaken
